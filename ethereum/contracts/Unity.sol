pragma solidity ^0.4.23;


contract Unity {

    // Define the structure of a land.
    struct Land {
        bytes2 district;
        uint document;
        uint landParcel;
        uint subaltern;
        address ownerAddress;
        uint landID;
    }

    struct EntryHistory {
        address ownerAddress;
        uint timestamp;
    }

    address public owner;   // address of who creates the contract

    // One landId can have multiple passed owners.
    mapping(uint => EntryHistory[]) public __history;

    // One account can hold many lands
    mapping(address => Land[]) public __ownedLands;

    // Total no of lands via this contract at any time
    uint public totalLandsCounter;

    // When the contract is deployed by truffle the account that deploys the contract became the owner,
    // in our case it will be the first account generated by ganache-cli (accounts[0]).
    constructor () public{
        owner = msg.sender;
        totalLandsCounter = 0;
    }

    // Land addition event, use this to synchronize with the backend.
    event Add(address _owner, uint _landID);

    // Land transfer event, also use this tho synchronize with the backend.
    event Transfer(address indexed _from, address indexed _to, uint _landID);

    // Modifier to check if the address of the calling (from field in the transaction obj) is the owner.
    modifier isOwner{
        require(msg.sender == owner, "Not authorized");
        _;
    }

    // Modifier used to check if current land is already present in the array associated to the user.
    modifier isUnique (uint _landParcel, address _ownerAddress){
        bool duplicate = false;
        for (uint i = 0; i < (__ownedLands[_ownerAddress].length); i++) {
            if (__ownedLands[_ownerAddress][i].landParcel == _landParcel) {
                duplicate = true;
                break;
            }
        }
        require(duplicate == false, "Duplicate land");
        _;
    }

    // Owner can add by using this function and by passing all the necessary data for creating a land obj.
    function addLand(bytes2 _district, uint _document, uint _landParcel, uint _subaltern, address _ownerAddress) public isOwner isUnique(_landParcel, _ownerAddress) returns (address) {

        totalLandsCounter = totalLandsCounter + 1;
        Land memory myLand = Land({
            district : _district,
            document : _document,
            landParcel : _landParcel,
            subaltern : _subaltern,
            ownerAddress : _ownerAddress,
            landID : totalLandsCounter
            });

        __ownedLands[_ownerAddress].push(myLand);

        // Add history entry for this new land.
        EntryHistory memory myEntry = EntryHistory({
            ownerAddress : _ownerAddress,
            timestamp : block.timestamp
            });
        __history[totalLandsCounter].push(myEntry);

        emit Add(_ownerAddress, totalLandsCounter);
        return msg.sender;
    }


    // Caller (owner/anyone) can transfer a land to the provided buyer if the caller is the owner of the requested land.
    function transferLand(address _landBuyer, uint _landParcel) public returns (bool) {
        // Find out the particular land ID in owner's collection.
        for (uint i = 0; i < (__ownedLands[msg.sender].length); i++) {
            // If so, then the land ID is in owner's collection.
            if (__ownedLands[msg.sender][i].landParcel == _landParcel) {
                // Copy land in buyers's collection.
                Land memory myLand = Land(
                    {
                    district : __ownedLands[msg.sender][i].district,
                    document : __ownedLands[msg.sender][i].document,
                    landParcel : _landParcel,
                    subaltern : __ownedLands[msg.sender][i].subaltern,
                    ownerAddress : _landBuyer,
                    landID : __ownedLands[msg.sender][i].landID
                    });
                __ownedLands[_landBuyer].push(myLand);

                // Insert movement in the history mapping.
                EntryHistory memory myEntry = EntryHistory({
                    ownerAddress : _landBuyer,
                    timestamp : block.timestamp
                    });
                __history[totalLandsCounter].push(myEntry);

                // Remove land from current ownerAddress.
                delete __ownedLands[msg.sender][i];

                // Inform the backend or who is subscribed to the event.
                emit Transfer(msg.sender, _landBuyer, _landParcel);

                return true;
            }
        }

        return false;
    }


    // Get land details of an account.
    function getLand(address _landHolder, uint _index) public view returns (bytes2, uint, uint, uint, address, uint) {
        return (
        __ownedLands[_landHolder][_index].district,
        __ownedLands[_landHolder][_index].document,
        __ownedLands[_landHolder][_index].landParcel,
        __ownedLands[_landHolder][_index].subaltern,
        __ownedLands[_landHolder][_index].ownerAddress,
        __ownedLands[_landHolder][_index].landID);

    }

    // Get total number of lands for a given account.
    function getNoOfLands(address _landHolder) public view returns (uint) {
        return __ownedLands[_landHolder].length;
    }

    // Return all the movements for a specific land.
    function getHistory(uint _landId, uint _index) public view returns (address, uint) {
        return (
        __history[_landId][_index].ownerAddress,
        __history[_landId][_index].timestamp
        );
    }

    // Return number of movements for a specific land.
    function getNoOfEntries(uint _landId) public view returns (uint){
        return __history[_landId].length;
    }
}